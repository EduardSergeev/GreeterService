# gRPC/Protobuf code generation example

[MSDN gRPC example](https://learn.microsoft.com/en-us/aspnet/core/grpc/) implemented using [IndependentReserve.Grpc.Tools](https://www.nuget.org/packages/IndependentReserve.Grpc.Tools/#readme-body-tab) package

[![Build Status](https://github.com/EduardSergeev/GreeterService/workflows/build/badge.svg)](https://github.com/EduardSergeev/GreeterService/actions?query=workflow%3Abuild+branch%3Amaster)
[![Linux benchmarks](https://eduardsergeev.github.io/GreeterService/bench-linux.svg)](https://eduardsergeev.github.io/GreeterService/ubuntu-latest/results/SingleDto-report.html)
[![Windows benchmarks](https://eduardsergeev.github.io/GreeterService/bench-windows.svg)](https://eduardsergeev.github.io/GreeterService/windows-latest/results/SingleDto-report.html)

## How to run it

Server:

```console
cd Greeter.Service
dotnet run
```

Client:

```console
cd Greeter.Client
dotnet run
```

Tests:

```console
cd Greeter.Test
dotnet test
```

Docker:

```console
docker build -t greeter-service -f Greeter.Service/Dockerfile .
docker run -it --rm -p 5001:443 greeter-service
```

Benchmarks:

```console
cd Greeter.Bench
dotnet run -c Release
```

## Benchmark results

Latest benchmark results can be found on [docs](../docs/docs) branch:
- [Linux](../docs/docs/ubuntu-latest/results)
- [Windows](../docs/docs/windows-latest/results)

<details>
  <summary>Benchmark results example:</summary>

[Serialisation](Greeter.Bench/StringArraySerialisation.cs) of `string[]` vs `string?[]` collection (vs JSON serialisation as baseline):

<a href="https://eduardsergeev.github.io/GreeterService/ubuntu-latest/results/StringArraySerialisation-report.html">
    <img src="https://eduardsergeev.github.io/GreeterService/ubuntu-latest/results/StringArraySerialisation-barplot.png" height="500"/>
</a>

</details>


## Quickstart tutorial

### The purpose of the package

The standard way to implement gRPC service in .NET is to use [Grpc.AspNetCore](https://www.nuget.org/packages/Grpc.AspNetCore) package (which in turn uses [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools) package to generate gRPC code from `*.proto` files). However this approach requires [Protobuf](https://en.wikipedia.org/wiki/Protocol_Buffers) data format to be used to define service and data contracts.  
Protobuf is not a part of .NET so the necessity to define and maintain service contracts in it increases code complexity. There is also some mismatch between .NET data types and Protobuf data types which often requires ad-hoc solutions.  

What [IndependentReserve.Grpc.Tools](https://www.nuget.org/packages/IndependentReserve.Grpc.Tools/#readme-body-tab) package does is it generates all required Protobuf definitions from a plain .NET ([POCO](https://en.wikipedia.org/wiki/Plain_old_CLR_object)) interface during the build time and then feeds generated entities to `Grpc.Tools` for subsequent processing. Along with Protobuf definitions `IndependentReserve.Grpc.Tools` also generates C# plumbing code which closes the gap between original .NET data types and gRPC data types generated by `Grpc.Tools` by providing gRPC service and client implementations which work with the original data types referenced by the contract interface.  
Effectively when `IndependentReserve.Grpc.Tools` is added to the mix developer only needs to define a service contract via a plain .NET interface from which the rest of gRPC code will be generated during the build automatically. Note: the core of gRPC code is still created by `Grpc.Tools` package and generated .NET code runs on `Grpc.AspNetCore` infrastructure but the necessity to write Protobuf code and .NET <-> Protobuf conversion code is removed by `IndependentReserve.Grpc.Tools` package addition.  

We will create a simple greeter gRPC service and client with a help of `IndependentReserve.Grpc.Tools` package. But to demonstrate the package abilities we will use a bit more involved greeter service contract which uses .NET classes as input and output parameters.  
The resulting source code can also be found in [./Tutorial](./Tutorial) directory.

### Step by step tutorial


#### Create service contract project  

Service contract interface(s) must be placed in a project/assembly separate from the project where gRPC code is generated because `IndependentReserve.Grpc.Tools` package uses reflection to load and analyse source interfaces so lets create a new library project `Greeter.Common`:

```console
dotnet new classlib -o Greeter.Common
```

and add the following service contract interface [IGreeterService](./Tutorial/Greeter.Common/IGreeterService.cs) to it:

```c#
namespace Greeter.Common;

public interface IGreeterService
{
    Greeting SayGreeting(Person person);    
}
```

along with all [referenced data classes](./Tutorial/Greeter.Common/DTO) (service [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)'s):

Input parameter class:

```c#
namespace Greeter.Common;

public readonly record struct Person
(
    Name Name,
    DateTime? DateOfBirth,
    Address[] Addresses
);
```

<details>
  <summary>And its dependent classes:</summary>

  The package distinguishes between nullable and non-nullable types:

  ```c#
  public readonly record struct Name
  (
      Title Title,
      string FirstName,
      string LastName,
      string? MiddleName = null
  );
  ```

  Enums are natively supported:

  ```c#
  public enum Title
  {
      Mr, Mrs, Miss, Ms, Sir, Dr
  }
  ```
  
  Non-nullable collections (e.g. `string[]`) produce more efficient Protobuf code:

  ```c#
  public readonly record struct Address
  (
      string[] Street,
      string City,
      string? State,
      uint? Postcode,
      string? Country
  );
  ```

</details>
  

and output parameter class:

```c#
public readonly record struct Greeting
(
    string Subject,
    IEnumerable<string> Lines
);
```

This is it for the source interface projects, lets just compile it to check that everything is in order:

```console
dotnet build Greeter.Common
```

#### Create common gRPC code project

This project will contain gRPC code generated from the source source interface.  

Create a new library project `Greeter.Grpc`:

```console
dotnet new classlib -o Greeter.Grpc
```

Add a package references to [IndependentReserve.Grpc](https://www.nuget.org/packages/IndependentReserve.Grpc) and to [IndependentReserve.Grpc.Tools](https://www.nuget.org/packages/IndependentReserve.Grpc.Tools):

```console
dotnet add Greeter.Grpc package IndependentReserve.Grpc
dotnet add Greeter.Grpc package IndependentReserve.Grpc.Tools
```

<details>
  <summary>Why do we need two packages:</summary>

  Actually if you just manually add `PackageReference` to `IndependentReserve.Grpc.Tools` like that:

  ```xml
  <ItemGroup>
    <PackageReference Include="IndependentReserve.Grpc.Tools" Version="4.1.215" />
  </ItemGroup>
  ```

  the reference to `IndependentReserve.Grpc` is added implicitly (transitively) so it does not have to be added explicitly.  
  However due to a bug in the [latest IndependentReserve.Grpc.Tools](https://www.nuget.org/packages/IndependentReserve.Grpc.Tools/4.1.215) when the package reference to it is added via `dotnet add` command a set of `<*Assets/>` attributes are added by `dotnet add` command:

  ```xml
  <ItemGroup>
    <PackageReference Include="IndependentReserve.Grpc.Tools" Version="4.1.215">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>
  ```

  These unnecessary `<*Assets/>` attributes break transitive dependency on `IndependentReserve.Grpc` which later result in compilation errors due to missing dependent types from `IndependentReserve.Grpc`.  

</details>

Add a project reference to the source interface project:

```console
dotnet add Greeter.Grpc reference Greeter.Common
```

To generate gRPC code from the source interface(s) from the referenced project add `GenerateGrpc` attribute to newly added reference in [Greeter.Grpc.csproj](./Tutorial/Greeter.Grpc/Greeter.Grpc.csproj#L18) file:

```xml
<ItemGroup>
  <ProjectReference Include="..\Greeter.Common\Greeter.Common.csproj" GenerateGrpc="true" />
</ItemGroup>
```

The tool uses [convention over configuration](https://en.wikipedia.org/wiki/Convention_over_configuration) approach and by default any public interface with name which ends with `Service` is considered being a service contract.

<details>
    <summary>If you prefer a different contract interface naming:</summary>

By default the tool searches for all public interfaces which names match `Service$` regular expression (e.g. `ISomeService`) and generates all required gRPC-related code for every found interface.  
To use a different pattern for interface search specify a custom regular expression (.NET flavor) via `GrpcServicePattern` attribute, e.g.:

```xml
<ItemGroup>
  <ProjectReference Include="..\Greeter.Common\Greeter.Common.csproj" >
    <GenerateGrpc>true</GenerateGrpc>
    <GrpcServicePattern>I[^.]*ServiceInterface$</GrpcServicePattern>
  </ProjectReference>
</ItemGroup>
```

</details>

Build the project:

```console
dotnet build Greeter.Grpc
```

Make sure there is no build errors or warnings.

Once compiled successfully `Greeter.Grpc` should include a set of generated `*.proto` and `*.cs` files which are automatically added to build. However a developer only need to know about two generated C# classes:

- gRPC service class `Greeter.Common.Grpc.GreeterServiceGrpcService`:  
  This is a standard gRPC service class (derived from `GreeterServiceBase` class generated by `Grpc.Tools`) which depends on `IGreeterService` interface implementation and simply exposes this implementation via gRPC protocol. This class processes incoming gPRC calls by calling dependent gRPC-agnostic `IGreeterService` implementation while taking care of DTO <-> Protobuf conversion for input and output parameters.
- gRPC client class `Greeter.Common.Grpc.GreeterServiceGrpcClient`:  
  This class implements `IGreeterService` interface by calling the service via gRPC. Internally it uses `GreeterServiceClient` class generated by `Grpc.Tools`.

<details>
  <summary>Where can I see generated files:</summary>

  All files generated by the package are placed in `obj/{Configuration}/{TargetFramework}/Grpc` directory root. All `*.proto` files are placed in `Protos` subdirectory while all `*.cs` files are generated in `Partials` subdirectory.  
  More specifically both gRPC service and client classes described above can be found at: `obj/{Configuration}/{TargetFramework}/Grpc/Partials/Greeter/Common/GreeterService`.

</details>

#### Create gRPC service project
 
Create an empty ASP.NET project:

```console
dotnet new web -o Greeter.Service
```

Add a package reference to [Grpc.AspNetCore](https://www.nuget.org/packages/Grpc.AspNetCore) package:

```console
dotnet add Greeter.Service package Grpc.AspNetCore
```

Add a project reference to [Greeter.Grpc](./Tutorial/Greeter.Grpc) project:

```console
dotnet add Greeter.Service reference Greeter.Grpc
```

Successfully built [Greeter.Grpc](./Tutorial/Greeter.Grpc) project will contain generated gRPC service class `Greeter.Common.Grpc.GreeterServiceGrpcService` which we can host in ASP.NET application:
First add gRPC support to ASP.NET app:

```c#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddGrpc();
```

Then map generated gRPC service class as gRPC service:

```c#
var app = builder.Build();
app.MapGrpcService<Greeter.Common.Grpc.GreeterServiceGrpcService>();
```

Since `GreeterServiceGrpcService` expects an implementation of `IGreeterService` to be passed to its constructor and this implementation is expected to contain the actual service logic lets add a simple gRPC-agnostic implementation of `IGreeterService`:

```c#
using Greeter.Common;
namespace Greeter.Service;

public class GreeterService : IGreeterService
{
    public Greeting SayGreeting(Person person)
    {
        var name = person.Name;

        var detailLines = new[]
        {
            $"Your details are:",
            $"DOB: {person.DateOfBirth:dd MMMM yyyy}",
            "",
        };

        return new Greeting
        {
            Subject = $"Hello {name.Title} {name.LastName}!",
            Lines = new[]
            {
                "",
                $"Dear {name.FirstName} {name.LastName},",
                "",
            }
            .Concat(detailLines)
        };
    }
}
```

and register it for dependency injection in `Program.cs`:

```c#
builder.Services.AddScoped<IGreeterService, GreeterService>();
```

Resulting `Program.cs` should now look like this:

```c#
using Greeter.Common;
using Greeter.Service;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddGrpc();
builder.Services.AddScoped<IGreeterService, GreeterService>();
    
var app = builder.Build();
app.MapGrpcService<Greeter.Common.Grpc.GreeterServiceGrpcService>();

app.Run();
```

Also make sure that service's `appsettings.json` specifies service port and HTTP/2 protocol:

```json
{
  "Urls": "http://*:5000;https://*:5001",
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  }
}
```

You should now be able to build and run resulting service:

```c#
dotnet build Greeter.Service
dotnet run --project Greeter.Service
```

### Create gRPC client project

Create new console project `Greeter.Client`:

```console
dotnet new console -o Greeter.Client
```

Add project reference to `Greeter.Grpc`:

```console
dotnet add Greeter.Client reference Greeter.Grpc
```

To instantiate generated client class we need to pass gRPC configuration via class which implements `IGrpcServiceConfiguration` interface so lets add a simple implementation which passes only service's URL and does not use client or checks service's TLS certificate:

```c#
using Ir.Common.Configuration.Grpc;
namespace Greeter.Client;

public class GrpcConfiguration : IGrpcServiceConfiguration
{
    public string Address { get; set; } = "http://localhost:5000";
    public ICertificateConfiguration? ClientCertificate => null;
    public ICertificateConfiguration? ServiceCertificate => null;
}
```

Now to call `Greeter.Service` over gRPC we just need to instantiate gRPC client class `Greeter.Common.Grpc.GreeterServiceGrpcClient` generated in `Greeter.Grpc` project and call its implementation of `IGreeterService`:

```c#
using Greeter.Client;
using Greeter.Common;
using static Greeter.Common.Title;
using static System.Console;

var client = new Greeter.Common.Grpc.GreeterServiceGrpcClient(new GrpcConfiguration());

var person = new Person
{
    Name = new()
    {
        Title = Mr,
        FirstName = "Eric",
        LastName = "Cartman",
    },
    DateOfBirth = new(DateTime.Now.Year - 10, 7, 1),
    Addresses =
    [
        new Address
        {
            Street = [ "28201 E. Bonanza St." ],
            City = "South Park",
            State = "Colorado",
            Country = "USA",
            Postcode = 80440
        },
    ]
};

WriteGreeting(client.SayGreeting(person));
WriteGreeting(await client.SayGreetingAsync(person));


void WriteGreeting(Greeting greeting)
{
    WriteLine(greeting.Subject);
    foreach(var line in greeting.Lines)
    {
        WriteLine(line);
    }
}
```

The client can now be built and run via:

```console
dotnet build Greeter.Client
dotnet run --project Greeter.Client
```
